/**
 * Extension API - Fetch Any User's Top Tweets
 * 
 * GET /api/extension/user-top-tweets?username=handle
 * 
 * Fetches a user's last 100 tweets and sorts by engagement score.
 * Returns top 10 tweets with a style summary generated by AI.
 * Used by the Chrome extension's Stats tab to show top-performing tweets.
 */

import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { getValidXTokens } from '@/lib/x-tokens';
import Anthropic from '@anthropic-ai/sdk';

// CORS headers for extension requests
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization',
};

// Handle CORS preflight
export async function OPTIONS() {
  return new NextResponse(null, { status: 204, headers: corsHeaders });
}

// Helper to add CORS headers to responses
function jsonResponse(data: unknown, options: { status?: number; headers?: Record<string, string> } = {}) {
  return NextResponse.json(data, { 
    status: options.status || 200,
    headers: corsHeaders 
  });
}

interface XTweet {
  id: string;
  text: string;
  created_at: string;
  public_metrics?: {
    like_count: number;
    retweet_count: number;
    reply_count: number;
    quote_count: number;
    impression_count?: number;
  };
}

interface XUser {
  id: string;
  name: string;
  username: string;
  profile_image_url?: string;
}

// Calculate engagement score: weighted sum of all metrics
function calculateEngagementScore(metrics: XTweet['public_metrics']): number {
  if (!metrics) return 0;
  // Replies are weighted highest (shows conversation), then likes, then retweets
  return (
    (metrics.reply_count || 0) * 3 +
    (metrics.like_count || 0) * 2 +
    (metrics.retweet_count || 0) * 2 +
    (metrics.quote_count || 0) * 1.5
  );
}

// Generate style summary using AI
async function generateStyleSummary(tweets: XTweet[], username: string): Promise<string> {
  if (!process.env.ANTHROPIC_API_KEY || tweets.length === 0) {
    return 'Style analysis unavailable.';
  }

  try {
    const anthropic = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY,
    });

    const tweetTexts = tweets.slice(0, 10).map(t => t.text).join('\n---\n');
    
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 200,
      messages: [
        {
          role: 'user',
          content: `Analyze @${username}'s writing style based on their top tweets. Describe their style in 2-3 short sentences. Focus on: tone, common themes, formatting habits, voice.

TWEETS:
${tweetTexts}

Respond with ONLY the style summary, nothing else. Be specific and insightful.`
        }
      ],
    });

    const content = response.content[0];
    if (content.type === 'text') {
      return content.text.trim();
    }
    return 'Style analysis unavailable.';
  } catch (error) {
    console.error('Style summary generation error:', error);
    return 'Style analysis unavailable.';
  }
}

export async function GET(request: NextRequest) {
  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!
  );

  try {
    // Verify auth
    const authHeader = request.headers.get('Authorization');
    if (!authHeader?.startsWith('Bearer ')) {
      return jsonResponse(
        { error: 'Missing or invalid authorization header' },
        { status: 401 }
      );
    }

    const token = authHeader.replace('Bearer ', '');
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);

    if (authError || !user) {
      return jsonResponse(
        { error: 'Invalid or expired token' },
        { status: 401 }
      );
    }

    // Get username from query params
    const searchParams = request.nextUrl.searchParams;
    const username = searchParams.get('username')?.replace('@', '');

    if (!username) {
      return jsonResponse(
        { error: 'Username is required' },
        { status: 400 }
      );
    }

    // Try user's OAuth tokens first, fall back to app Bearer token
    let accessToken: string;
    const tokenResult = await getValidXTokens(user.id);
    
    console.log('[user-top-tweets] Token result:', { success: tokenResult.success, hasTokens: tokenResult.success && !!tokenResult.tokens });
    
    if (tokenResult.success && tokenResult.tokens) {
      accessToken = tokenResult.tokens.access_token;
      console.log('[user-top-tweets] Using user OAuth token');
    } else {
      // Fallback to app Bearer token for public data
      const bearerToken = process.env.X_BEARER_TOKEN;
      console.log('[user-top-tweets] Bearer token present:', !!bearerToken, 'length:', bearerToken?.length || 0);
      if (!bearerToken) {
        console.error('[user-top-tweets] X_BEARER_TOKEN env var is missing!');
        return jsonResponse(
          { error: 'X API not configured' },
          { status: 500 }
        );
      }
      accessToken = decodeURIComponent(bearerToken);
      console.log('[user-top-tweets] Using app Bearer token, decoded length:', accessToken.length);
    }

    // Step 1: Look up user ID from username
    const userLookupUrl = `https://api.x.com/2/users/by/username/${username}?user.fields=name,username,profile_image_url`;
    
    const userResponse = await fetch(userLookupUrl, {
      headers: {
        'Authorization': `Bearer ${accessToken}`,
      },
    });

    if (!userResponse.ok) {
      if (userResponse.status === 404) {
        return jsonResponse(
          { error: 'User not found' },
          { status: 404 }
        );
      }
      const error = await userResponse.text();
      console.error('X API user lookup error:', error);
      return jsonResponse(
        { error: 'Failed to find user on X' },
        { status: userResponse.status }
      );
    }

    const userData = await userResponse.json();
    const targetUser: XUser = userData.data;

    if (!targetUser) {
      return jsonResponse(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    // Step 2: Fetch user's tweets (last 100)
    const tweetsUrl = new URL(`https://api.x.com/2/users/${targetUser.id}/tweets`);
    tweetsUrl.searchParams.set('max_results', '100');
    tweetsUrl.searchParams.set('tweet.fields', 'created_at,public_metrics');
    tweetsUrl.searchParams.set('exclude', 'retweets,replies');

    const tweetsResponse = await fetch(tweetsUrl.toString(), {
      headers: {
        'Authorization': `Bearer ${accessToken}`,
      },
    });

    if (!tweetsResponse.ok) {
      const error = await tweetsResponse.text();
      console.error('X API tweets error:', error);
      return jsonResponse(
        { error: 'Failed to fetch tweets' },
        { status: tweetsResponse.status }
      );
    }

    const tweetsData = await tweetsResponse.json();
    const rawTweets: XTweet[] = tweetsData.data || [];

    // Step 3: Sort by engagement score (descending) and take top 10
    const sortedTweets = rawTweets
      .filter(t => t.public_metrics)
      .sort((a, b) => calculateEngagementScore(b.public_metrics) - calculateEngagementScore(a.public_metrics))
      .slice(0, 10);

    // Step 4: Generate style summary using AI
    const styleSummary = await generateStyleSummary(sortedTweets, targetUser.username);

    // Step 5: Transform for response
    const tweets = sortedTweets.map(tweet => ({
      id: tweet.id,
      text: tweet.text,
      url: `https://x.com/${targetUser.username}/status/${tweet.id}`,
      created_at: tweet.created_at,
      replies: tweet.public_metrics?.reply_count || 0,
      likes: tweet.public_metrics?.like_count || 0,
      retweets: tweet.public_metrics?.retweet_count || 0,
      views: tweet.public_metrics?.impression_count || 0,
    }));

    // Track usage
    await supabase
      .from('generation_usage')
      .insert({
        user_id: user.id,
        type: 'extension_top_tweets_scan',
        tokens_used: 0,
        created_at: new Date().toISOString()
      });

    return jsonResponse({
      handle: `@${targetUser.username}`,
      avatar: targetUser.profile_image_url || '',
      styleSummary,
      tweets,
      scannedAt: new Date().toISOString(),
    });

  } catch (error) {
    console.error('User top tweets API error:', error);
    return jsonResponse(
      { error: 'Failed to fetch user tweets' },
      { status: 500 }
    );
  }
}
